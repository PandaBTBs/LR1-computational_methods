
def lu_decomposition(A):
    
# Алгоритм разложения (метод Дулиттла):
# Последовательно находим строки U и столбцы L
# Используем уже найденные элементы для вычисления новых
# На каждом шаге используем формулу: aᵢⱼ = Σ(lᵢₖ × uₖⱼ) для k = 1..n

    # (L, U) - нижнюю и верхнюю треугольные матрицы
    
    
    n = len(A)
    L = [[0.0] * n for _ in range(n)]
    U = [[0.0] * n for _ in range(n)]

    for i in range(n):
        L[i][i] = 1.0
    
    for i in range(n): # проходим по всем строкам и столбцам
        for k in range(i, n):   # заполняем элементы U в строке i, начиная с диагонали (k ≥ i)
            sum_u = 0
            # Когда i = 0: внутренний цикл выполняется для k = 0, 1, 2 (3 итерации)
            # Когда i = 1: внутренний цикл выполняется для k = 1, 2 (2 итерации)
            # Когда i = 2: внутренний цикл выполняется для k = 2 (1 итерация)
            
            #j < i
            for j in range(i):
                sum_u += L[i][j] * U[j][k]
                
# Вывод формулы для U[i][k]
# Рассмотрим элемент U[i][k] (i ≤ k, так как U верхняя треугольная).

# Из уравнения A = L×U:
# aᵢₖ = Σ(lᵢⱼ × uⱼₖ) для j = 1..n

# aᵢₖ = [Σ(lᵢⱼ × uⱼₖ) для j < i] + [Σ(lᵢⱼ × uⱼₖ) для j ≥ i]

# Но для j > i, uⱼₖ = 0 (так как U верхняя треугольная). Поэтому:
# aᵢₖ = [Σ(lᵢⱼ × uⱼₖ) для j < i] + [lᵢᵢ × uᵢₖ]

# Так как lᵢᵢ = 1 (единичная диагональ у L):
# aᵢₖ = [Σ(lᵢⱼ × uⱼₖ) для j < i] + uᵢₖ
# Отсюда:
# uᵢₖ = aᵢₖ - Σ(lᵢⱼ × uⱼₖ) для j < i
                
                # для j < i
            U[i][k] = A[i][k] - sum_u
        
        for k in range(i + 1, n): #заполняем элементы L в столбце i, ниже диагонали (k > i)
            sum_l = 0
            for j in range(i):
                sum_l += L[k][j] * U[j][i]
            if U[i][i] == 0:
                raise ValueError("Матрица вырождена, LU-разложение невозможно")
            
            
            
            
# Вывод формулы для L[k][i]

# Рассмотрим элемент L[k][i] (k > i, так как ниже диагонали).


# Но для j > i, uⱼᵢ = 0 (так как U верхняя треугольная, а j > i). 
# Поэтому:
# aₖᵢ = [Σ(lₖⱼ × uⱼᵢ) для j < i] + [lₖᵢ × uᵢᵢ]

# Выражаем lₖᵢ:

# lₖᵢ × uᵢᵢ = aₖᵢ - Σ(lₖⱼ × uⱼᵢ) для j < i
# Отсюда:
# lₖᵢ = (aₖᵢ - Σ(lₖⱼ × uⱼᵢ) для j < i) / uᵢᵢ

# Именно это и есть формула: 
#     L[k][i] = (A[k][i] - sum_l) / U[i][i], где sum_l = Σ(lₖⱼ × uⱼᵢ) для j < i.

            # j < i
            L[k][i] = (A[k][i] - sum_l) / U[i][i] #Элемент L[k][i] = (A[k][i] - сумма) / U[i][i]
    
    return L, U

def determinant_lu(A):

    n = len(A)
    
    
    # Получаем LU-разложение
    L, U = lu_decomposition(A)
    
    # Определитель = произведение диагональных элементов U
    # (так как det(L) = 1 из-за единичной диагонали)
    det = 1.0
    for i in range(n):
        det *= U[i][i]
    
    return det


A = [
    [4, 3, 2],
    [2, 1, 3],
    [3, 4, 2]
]
    
print("Матрица A:")
for row in A:
    print(row)
    
det = determinant_lu(A)
print(f"\nОпределитель матрицы: {det}")
        




L, U = lu_decomposition(A)
print("\nМатрица L (с единичной диагональю):")
for row in L:
    print([round(x, 4) for x in row])
        
print("\nМатрица U:")
for row in U:
    print([round(x, 4) for x in row])
            
            
            
            
            
# Как мы получаем: 
    
# U[i][k] = A[i][k] - sum_u  
     
# L[k][i] = (A[k][i] - sum_l) / U[i][i]v
            

# Когда i = 0: внутренний цикл выполняется для k = 0, 1, 2 (3 итерации)
# Когда i = 1: внутренний цикл выполняется для k = 1, 2 (2 итерации)
# Когда i = 2: внутренний цикл выполняется для k = 2 (1 итерация)
            
            
# A = L × U

# [a₁₁ a₁₂ a₁₃]   [1    0    0 ]   [u₁₁ u₁₂ u₁₃]
# [a₂₁ a₂₂ a₂₃] = [l₂₁ 1    0 ] × [0   u₂₂ u₂₃]
# [a₃₁ a₃₂ a₃₃]   [l₃₁ l₃₂ 1 ]   [0   0   u₃₃]


# Элемент матрицы A с индексами (i, k) получается как сумма произведений 
# i-й строки L и k-го столбца U:


# aᵢₖ = Σ(lᵢⱼ × uⱼₖ) для j = 1..n


































def gauss(A, b):
    
    # Привидение к тр-ому виду
    n = len(A)
    Ab = [A[i] + [b[i]] for i in range(n)]
    for i in range(n):
        for k in range(i + 1, n):
            factor = Ab[k][i] / Ab[i][i] #множитель
            for j in range(i, n + 1): 
                Ab[k][j] -= factor * Ab[i][j]
    
    x = [0] * n 

    #Подстановка с конца
    for i in range(n - 1, -1, -1): #для обратного прохода по индексам списк
        # i = 2, 1, 0
        #x[2]=Ab[2][3] i=2 
        #x[1]=Ab[1][3] i=1 
        #x[0]=Ab[0][3] i=0
        x[i] = Ab[i][n] 
        for j in range(i + 1, n):
            x[i] -= Ab[i][j] * x[j]
        x[i] /= Ab[i][i]
    return x 


# 2x + y - z = 8
# -3x - y + 2z = -11
# -2x + y + 2z = -3
A = [[2, 1, -1],
    [-3, -1, 2],
    [-2, 1, 2]]
    
b = [8, -11, -3]
    
vectorX = gauss(A, b) 
print("Решение системы:")
for i, val in enumerate(vectorX):
    print(f"x{i+1} = {val:.6f}")

















# 2.	Вычисление определителя матрицы с помощью LU-разложения при фиксированной единич. диагонали у матрицы:	а) L


import numpy as np

def lu_decomposition(A):
    """
    Выполняет LU-разложение матрицы A с единичной диагональю у L
    A = L * U, где L - нижнетреугольная с единицами на диагонали,
    U - верхнетреугольная
    """
    n = len(A) #
    L = np.zeros((n, n))
    U = np.zeros((n, n))
    
    # L - будет нижнетреугольной матрицей
    # U - будет верхнетреугольной матрицей
    
    # Заполняем диагональ L единицами
    for i in range(n):
        L[i][i] = 1

    # Переменная i - текущий шаг разложения.
    
# Вычисление строки U[i][*]
# Мы вычисляем каждый элемент в строке i матрицы U.
    for i in range(n):
        for k in range(i, n): # k проходит от i до n-1 - это все столбцы от текущего до последнего.
            # Элементы левее i в строке U уже нули (по определению верхнетреугольной матрицы)
            sum_u = 0 
            for j in range(i):
                
                # A[i][k] = L[i][0]×U[0][k] + L[i][1]×U[1][k] + ... + L[i][i]×U[i][k] + ...
                # где L[i][i] = 1 => A[i][k] = (сумма для j=0 до i-1) + 1×U[i][k] => U[i][k] = A[i][k] - (сумма для j=0 до i-1)

                sum_u += L[i][j] * U[j][k] # sum_u вычисляет сумму произведений элементов из L и U, которые влияют на позицию [i][k]
            U[i][k] = A[i][k] - sum_u # Формула U[i][k] = A[i][k] - sum_u следует из равенства A = L × U:
        

# Пример для i=1, k=2:
# Нужно вычислить U[1][2]
# Суммируем: L[1][0]×U[0][2] (L[1][1] не участвует, так как j < i, т.е. j=0)
# U[1][2] = A[1][2] - эта сумма
        
        
        
        # Вычисление столбца L[*][i]
        for k in range(i+1, n): #все строки ниже текущей
            #  Для строк выше или равных i элемент L[k][i] при k < i уже определен (это нули или были вычислены ранее)
            # а L[i][i] = 1
            sum_l = 0
        
            for j in range(i):
                sum_l += L[k][j] * U[j][i]
                
                # A[k][i] = (сумма для j=0 до i-1) + L[k][i]×U[i][i]
            L[k][i] = (A[k][i] - sum_l) / U[i][i]
    

# Формула следует из равенства A = L × U для позиции [k][i]:


# A[k][i] = L[k][0]×U[0][i] + L[k][1]×U[1][i] + ... + L[k][i]×U[i][i] + ...
# Но для j > i элементы U[j][i] = 0. Поэтому:

# A[k][i] = (сумма для j=0 до i-1) + L[k][i]×U[i][i]
# Отсюда: L[k][i] = (A[k][i] - сумма) / U[i][i]   
    
    return L, U # Возвращает полученные матрицы L и U.

def determinant_from_lu(A):
    """
    Вычисляет определитель матрицы A через LU-разложение
    det(A) = det(L) * det(U) = 1 * det(U) (так как det(L)=1)
    det(U) = произведение диагональных элементов U
    """
    L, U = lu_decomposition(A)
    
    # Определитель = произведению диагональных элементов U
    det = 1 # det = 1 - инициализация определителя
    for i in range(len(U)):
        det *= U[i][i]
    
    return det, L, U # : Возвращает определитель и матрицы разложения.




    # Создаем тестовую матрицу
A = np.array([
    [4, 3, 2],
    [2, 5, 3],
    [3, 2, 6]
], dtype=float)
    
print("Исходная матрица A:")
print(A)
print()
    
# Вычисляем определитель через LU-разложение
det, L, U = determinant_from_lu(A)
    
print("Матрица L (с единичной диагональю):")
print(L)
print()
    
print("Матрица U:")
print(U)
print()
    
print(f"Определитель матрицы A (через LU-разложение): {det}")
print()
    
# Проверка: A = L * U
A2 = np.dot(L, U)
print("Восстановленная матрица A = L * U:")
print(A2)

# for i in range(3): print(i) # 0 1 2












# 2.	Вычисление определителя матрицы с помощью LU-разложения при фиксированной единич. диагонали у матрицы:	а) L


# import numpy as np


def lu_decomposition(A):
    n = len(A)  #
    # L = np.zeros((n, n))
    L = [[0.0]*n for _ in range(n)]
    # U = np.zeros((n, n))
    U=[[0.0] * n for _ in range(n)]

    # Переменная i - текущий шаг разложения.
    for i in range(n):
        L[i][i] = 1


    # Вычисление строки U[i][*]
    for i in range(n):
        for k in range(i, n):  # k проходит от i до n-1 - это все столбцы от текущего до последнего.
            # Элементы левее i в строке U уже нули (по определению верхнетреугольной матрицы)
            sum_u = 0
            for j in range(i):
                # A[i][k] = L[i][0]×U[0][k] + L[i][1]×U[1][k] + ... + L[i][i]×U[i][k] + ...
                # где L[i][i] = 1 => A[i][k] = (сумма для j=0 до i-1) + 1×U[i][k] => U[i][k] = A[i][k] - (сумма для j=0 до i-1)

                sum_u += L[i][j] * U[j][
                    k]  # sum_u вычисляет сумму произведений элементов из L и U, которые влияют на позицию [i][k]
            U[i][k] = A[i][k] - sum_u  # Формула U[i][k] = A[i][k] - sum_u следует из равенства A = L × U:


        # Вычисление столбца L[*][i]
        for k in range(i + 1, n):  # все строки ниже текущей
            #  Для строк выше или равных i элемент L[k][i] при k < i уже определен (это нули или были вычислены ранее)
            # а L[i][i] = 1
            sum_l = 0

            for j in range(i):
                sum_l += L[k][j] * U[j][i]

                # A[k][i] = (сумма для j=0 до i-1) + L[k][i]×U[i][i]
            L[k][i] = (A[k][i] - sum_l) / U[i][i]

    # Формула следует из равенства A = L × U для позиции [k][i]:

    # A[k][i] = L[k][0]×U[0][i] + L[k][1]×U[1][i] + ... + L[k][i]×U[i][i] + ...
    # Но для j > i элементы U[j][i] = 0.
    # Поэтому:
    # A[k][i] = (сумма для j=0 до i-1) + L[k][i]×U[i][i]
    # L[k][i] = (A[k][i] - сумма) / U[i][i]

    return L, U


def determinant_from_lu(A):
    L, U = lu_decomposition(A)


    det = 1
    for i in range(len(U)):
        det *= U[i][i]

    return det, L, U



A = [
    [4, 3, 2],
    [2, 5, 3],
    [3, 2, 6]
]

print("Исходная матрица A:")
print(A)
print()

# Вычисляем определитель через LU-разложение
det, L, U = determinant_from_lu(A)

print("Матрица L (с единичной диагональю):")
print(L)
print()

print("Матрица U:")
print(U)
print()

print(f"Определитель матрицы A (через LU-разложение): {det}")
print()

# Проверка: A = L * U
# A2 = np.dot(L, U)
# print("Восстановленная матрица A = L * U:")
# print(A2)

n=len(A)
A1 = [[0.0]*n for _ in range(n)]

for i in range(n):
    for j in range(n):
        s=0.0
        for k in range(n):
            s+=L[i][k]*U[k][j]
        A1[i][j]=s

for row in A1:
    print(row)
