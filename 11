def gauss(A, b):
    
    # Привидение к тр-ому виду
    n = len(A)
    Ab = [A[i] + [b[i]] for i in range(n)]
    for i in range(n):
        for k in range(i + 1, n):
            factor = Ab[k][i] / Ab[i][i] #множитель
            for j in range(i, n + 1): 
                Ab[k][j] -= factor * Ab[i][j]
    
    x = [0] * n 

    #Подстановка с конца
    for i in range(n - 1, -1, -1): #для обратного прохода по индексам списк
        # i = 2, 1, 0
        #x[2]=Ab[2][3] i=2 
        #x[1]=Ab[1][3] i=1 
        #x[0]=Ab[0][3] i=0
        x[i] = Ab[i][n] 
        for j in range(i + 1, n):
            x[i] -= Ab[i][j] * x[j]
        x[i] /= Ab[i][i]
    return x 


# 2x + y - z = 8
# -3x - y + 2z = -11
# -2x + y + 2z = -3
A = [[2, 1, -1],
    [-3, -1, 2],
    [-2, 1, 2]]
    
b = [8, -11, -3]
    
vectorX = gauss(A, b) 
print("Решение системы:")
for i, val in enumerate(vectorX):
    print(f"x{i+1} = {val:.6f}")

















# 2.	Вычисление определителя матрицы с помощью LU-разложения при фиксированной единич. диагонали у матрицы:	а) L


import numpy as np

def lu_decomposition(A):
    """
    Выполняет LU-разложение матрицы A с единичной диагональю у L
    A = L * U, где L - нижнетреугольная с единицами на диагонали,
    U - верхнетреугольная
    """
    n = len(A) #
    L = np.zeros((n, n))
    U = np.zeros((n, n))
    
    # L - будет нижнетреугольной матрицей
    # U - будет верхнетреугольной матрицей
    
    # Заполняем диагональ L единицами
    for i in range(n):
        L[i][i] = 1

    # Переменная i - текущий шаг разложения.
    
# Вычисление строки U[i][*]
# Мы вычисляем каждый элемент в строке i матрицы U.
    for i in range(n):
        for k in range(i, n): # k проходит от i до n-1 - это все столбцы от текущего до последнего.
            # Элементы левее i в строке U уже нули (по определению верхнетреугольной матрицы)
            sum_u = 0 
            for j in range(i):
                
                # A[i][k] = L[i][0]×U[0][k] + L[i][1]×U[1][k] + ... + L[i][i]×U[i][k] + ...
                # где L[i][i] = 1 => A[i][k] = (сумма для j=0 до i-1) + 1×U[i][k] => U[i][k] = A[i][k] - (сумма для j=0 до i-1)

                sum_u += L[i][j] * U[j][k] # sum_u вычисляет сумму произведений элементов из L и U, которые влияют на позицию [i][k]
            U[i][k] = A[i][k] - sum_u # Формула U[i][k] = A[i][k] - sum_u следует из равенства A = L × U:
        

# Пример для i=1, k=2:
# Нужно вычислить U[1][2]
# Суммируем: L[1][0]×U[0][2] (L[1][1] не участвует, так как j < i, т.е. j=0)
# U[1][2] = A[1][2] - эта сумма
        
        
        
        # Вычисление столбца L[*][i]
        for k in range(i+1, n): #все строки ниже текущей
            #  Для строк выше или равных i элемент L[k][i] при k < i уже определен (это нули или были вычислены ранее)
            # а L[i][i] = 1
            sum_l = 0
        
            for j in range(i):
                sum_l += L[k][j] * U[j][i]
                
                # A[k][i] = (сумма для j=0 до i-1) + L[k][i]×U[i][i]
            L[k][i] = (A[k][i] - sum_l) / U[i][i]
    

# Формула следует из равенства A = L × U для позиции [k][i]:


# A[k][i] = L[k][0]×U[0][i] + L[k][1]×U[1][i] + ... + L[k][i]×U[i][i] + ...
# Но для j > i элементы U[j][i] = 0. Поэтому:

# A[k][i] = (сумма для j=0 до i-1) + L[k][i]×U[i][i]
# Отсюда: L[k][i] = (A[k][i] - сумма) / U[i][i]   
    
    return L, U # Возвращает полученные матрицы L и U.

def determinant_from_lu(A):
    """
    Вычисляет определитель матрицы A через LU-разложение
    det(A) = det(L) * det(U) = 1 * det(U) (так как det(L)=1)
    det(U) = произведение диагональных элементов U
    """
    L, U = lu_decomposition(A)
    
    # Определитель = произведению диагональных элементов U
    det = 1 # det = 1 - инициализация определителя
    for i in range(len(U)):
        det *= U[i][i]
    
    return det, L, U # : Возвращает определитель и матрицы разложения.




    # Создаем тестовую матрицу
A = np.array([
    [4, 3, 2],
    [2, 5, 3],
    [3, 2, 6]
], dtype=float)
    
print("Исходная матрица A:")
print(A)
print()
    
# Вычисляем определитель через LU-разложение
det, L, U = determinant_from_lu(A)
    
print("Матрица L (с единичной диагональю):")
print(L)
print()
    
print("Матрица U:")
print(U)
print()
    
print(f"Определитель матрицы A (через LU-разложение): {det}")
print()
    
# Проверка: A = L * U
A2 = np.dot(L, U)
print("Восстановленная матрица A = L * U:")
print(A2)

# for i in range(3): print(i) # 0 1 2
